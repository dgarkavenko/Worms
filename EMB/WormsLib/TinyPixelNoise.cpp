// Do not modify this file! See ASSIGNMENT.md.

/*
TinyPixelNoise

Copyright 2021 Jonas Kjellstrom

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include "TinyPixelNoise.h"

#include <memory>
#include <numeric>
#include <random>
#include <limits>
#include <cassert>
#include <atomic>
#include <cstdarg>
#include <cstdio>
#include <algorithm>
#include <cstring>

/*
   _____
  / ____|
 | |     ___  _ __ ___  _ __ ___   ___  _ __
 | |    / _ \| '_ ` _ \| '_ ` _ \ / _ \| '_ \
 | |___| (_) | | | | | | | | | | | (_) | | | |
  \_____\___/|_| |_| |_|_| |_| |_|\___/|_| |_|
*/



struct FAudioRingBuffer
{
	FAudioRingBuffer()
	{
		// With a default size of 1 GetWriteRange and Write are well defined.
		ChannelBuffers[0].resize(1);
		ChannelBuffers[1].resize(1);
		ReadIndex = 0;
		WriteIndex = 0;
		WriteAheadSamples = 0;
		Phase = 0.0f;
	}

	void Initialize(int InWriteAheadSamples, int InBufferSamples)
	{
		ChannelBuffers[0].resize(InBufferSamples);
		ChannelBuffers[1].resize(InBufferSamples);
		WriteAheadSamples = InWriteAheadSamples;
		WriteIndex += std::min(WriteAheadSamples, InBufferSamples - 1);
	}

	struct FRanges
	{
		int TotalLength() const
		{
			return (End0 - Begin0) + (End1 - Begin1);
		}
		int Begin0;
		int End0;
		int Begin1;
		int End1;
	};

	int PerChannelBufferLength() const
	{
		return static_cast<int>(ChannelBuffers[0].size());
	}

	FRanges GetWriteRange(int Samples) const
	{
		const int Read = ReadIndex;
		const int BufferCapacity = static_cast<int>(ChannelBuffers[0].size());
		const int BufferLength = (WriteIndex + BufferCapacity - Read) % BufferCapacity;
		const int WriteCapacity = BufferCapacity - BufferLength - 1;
		const int ExtraSamples = BufferLength < WriteAheadSamples ? WriteAheadSamples - BufferLength : 0;
		const int SamplesToWrite = std::min(WriteCapacity, Samples + ExtraSamples);
		auto Ranges = FRanges{ WriteIndex, WriteIndex + SamplesToWrite, 0, 0 };
		const int Overflow = Ranges.End0 - BufferCapacity;
		if (Overflow > 0)
		{
			Ranges.End0 -= Overflow;
			Ranges.End1 = Overflow;
		}
		return Ranges;
	}

	void Write(const FAudio& Audio, const FAudioRingBuffer::FRanges& AudioRange)
	{
		const auto Len0 = AudioRange.End0 - AudioRange.Begin0;
		const auto Len1 = AudioRange.End1 - AudioRange.Begin1;
		memcpy(ChannelBuffers[0].data() + AudioRange.Begin0, Audio.LChannel, Len0 * sizeof(float));
		memcpy(ChannelBuffers[0].data() + AudioRange.Begin1, Audio.LChannel + Len0, Len1 * sizeof(float));
		memcpy(ChannelBuffers[1].data() + AudioRange.Begin0, Audio.RChannel, Len0 * sizeof(float));
		memcpy(ChannelBuffers[1].data() + AudioRange.Begin1, Audio.RChannel + Len0, Len1 * sizeof(float));
		const int BufferCapacity = int(ChannelBuffers[0].size());
		WriteIndex.exchange((WriteIndex + AudioRange.TotalLength()) % BufferCapacity);
	}

	FRanges GetReadRange(int Samples) const
	{
		const int Read = ReadIndex;
		const int BufferCapacity = static_cast<int>(ChannelBuffers[0].size());
		const int BufferLength = (WriteIndex + BufferCapacity - Read) % BufferCapacity;
		const int SamplesToRead = std::min(BufferLength, Samples);
		auto Ranges = FRanges{ Read, Read + SamplesToRead, 0, 0 };
		const int Overflow = Ranges.End0 - BufferCapacity;
		if (Overflow > 0)
		{
			Ranges.End0 -= Overflow;
			Ranges.End1 = Overflow;
		}
		return Ranges;
	}

	void InterleavedReadInto(float* Buffer, const FAudioRingBuffer::FRanges& ReadRange)
	{
		const int BufferCapacity = static_cast<int>(ChannelBuffers[0].size());
		const float* LChannel = ChannelBuffers[0].data() + ReadRange.Begin0;
		const float* RChannel = ChannelBuffers[1].data() + ReadRange.Begin0;
		for (int i = ReadRange.Begin0; i < ReadRange.End0; ++i)
		{
			*Buffer++ = *LChannel++;
			*Buffer++ = *RChannel++;
		}
		LChannel = ChannelBuffers[0].data() + ReadRange.Begin1;
		RChannel = ChannelBuffers[1].data() + ReadRange.Begin1;
		for (int i = ReadRange.Begin1; i < ReadRange.End1; ++i)
		{
			*Buffer++ = *LChannel++;
			*Buffer++ = *RChannel++;
		}
		ReadIndex.exchange((ReadIndex + ReadRange.TotalLength()) % BufferCapacity);
	}

private:
	float Phase;
	std::vector<float> ChannelBuffers[2]; // Left and right channel
	std::atomic_int ReadIndex;
	std::atomic_int WriteIndex;
	int WriteAheadSamples;
};


// From http://xoroshiro.di.unimi.it/xoroshiro128plus.c
uint64_t xoroshiro128plus(void)
{
	static uint64_t s[2] = { 1, std::random_device()() };
	const auto rotl = [](const uint64_t x, int k) { return (x << k) | (x >> (64 - k)); };

	const uint64_t s0 = s[0];
	uint64_t s1 = s[1];
	const uint64_t result = s0 + s1;

	s1 ^= s0;
	s[0] = rotl(s0, 55) ^ s1 ^ (s1 << 14);
	s[1] = rotl(s1, 36);

	return result;
}

int RandomInt(int low, int high)
{
	return (xoroshiro128plus() % (static_cast<int64_t>(high) - low)) + low;
}

float RandomFloat()
{
	union U { uint32_t I; float F; };
	return U{ uint32_t{0x3F800000u} | static_cast<uint32_t>(xoroshiro128plus()) & ((uint32_t{1} << 23) - uint32_t{1}) }.F - 1.0f;
}

FRect FRect::FromPoints(const FVec2& A, const FVec2& B)
{
	auto Result = FRect{A, B};
	if (Result.Begin.X > Result.End.X)
		std::swap(Result.Begin.X, Result.End.X);
	if (Result.Begin.Y > Result.End.Y)
		std::swap(Result.Begin.Y, Result.End.Y);
	return Result;
}


// The first 256 characters from the awesome public domain unscii-16 font
// http://pelulamu.net/unscii/
static const uint8_t Unscii8x16[256][16] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEA, 0xEA, 0x2A, 0x2A, 0xEE, 0xEE, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEA, 0xEA, 0x2A, 0x2A, 0xE4, 0xE4, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCA, 0xCA, 0x8A, 0x8A, 0xE4, 0xE4, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCE, 0xCE, 0x84, 0x84, 0xE4, 0xE4, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCE, 0xCE, 0x8A, 0x8A, 0xEA, 0xEA, 0x0E, 0x0E, 0x04, 0x04, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEA, 0xEA, 0xAA, 0xAA, 0xAC, 0xAC, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xC8, 0xC8, 0xA8, 0xA8, 0xC8, 0xC8, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xCE, 0xCE, 0xA8, 0xA8, 0xCE, 0xCE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xA0, 0xA0, 0xA0, 0xA0, 0xEE, 0xEE, 0xA4, 0xA4, 0xA4, 0xA4, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00,
	0x80, 0x80, 0x80, 0x80, 0x8E, 0x8E, 0x88, 0x88, 0xEC, 0xEC, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0xA0, 0xA0, 0xA0, 0xA0, 0xAE, 0xAE, 0xA4, 0xA4, 0x44, 0x44, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCE, 0xCE, 0x88, 0x88, 0x8C, 0x8C, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0x8E, 0x8E, 0x8A, 0x8A, 0xEE, 0xEE, 0x0C, 0x0C, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEE, 0xEE, 0x2A, 0x2A, 0xEA, 0xEA, 0x0A, 0x0A, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEE, 0xEE, 0x24, 0x24, 0xE4, 0xE4, 0x04, 0x04, 0x0E, 0x0E, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xA8, 0xA8, 0xA8, 0xA8, 0xC8, 0xC8, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xA4, 0xA4, 0xAC, 0xAC, 0xC4, 0xC4, 0x04, 0x04, 0x0E, 0x0E, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xAE, 0xAE, 0xA2, 0xA2, 0xCE, 0xCE, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xAE, 0xAE, 0xA2, 0xA2, 0xC6, 0xC6, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xAA, 0xAA, 0xAA, 0xAA, 0xCE, 0xCE, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xAA, 0xAA, 0xAA, 0xAA, 0xAC, 0xAC, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEA, 0xEA, 0x2A, 0x2A, 0xEE, 0xEE, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCC, 0xCC, 0x8A, 0x8A, 0xEC, 0xEC, 0x0A, 0x0A, 0x0C, 0x0C, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0x8E, 0x8E, 0x8A, 0x8A, 0xEA, 0xEA, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCA, 0xCA, 0x8E, 0x8E, 0xEA, 0xEA, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0x3C, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x30, 0x30, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCE, 0xCE, 0x88, 0x88, 0xE8, 0xE8, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCE, 0xCE, 0x88, 0x88, 0x8E, 0x8E, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xAE, 0xAE, 0xA8, 0xA8, 0xEE, 0xEE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0xC8, 0xC8, 0xAE, 0xAE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xA0, 0xA0, 0xA0, 0xA0, 0xAE, 0xAE, 0xA8, 0xA8, 0xEE, 0xEE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x66, 0x3C, 0x18, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x06, 0xC6, 0xCC, 0xCC, 0x18, 0x18, 0x30, 0x30, 0x66, 0x66, 0xC6, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x30, 0x7A, 0xDE, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0C, 0x18, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x18, 0x0C, 0x00, 0x00,
	0x00, 0x30, 0x18, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x18, 0x30, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x18, 0x18, 0x30, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x03, 0x03, 0x06, 0x06, 0x0C, 0x0C, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60, 0xC0, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x06, 0x06, 0x1C, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x0C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x76, 0x3C, 0x6E, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x06, 0x0C, 0x38, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x38, 0x18, 0x18, 0x30, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3C, 0x66, 0x66, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0xC0, 0x7C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x60, 0x60, 0x60, 0x60, 0x60, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x60, 0x60, 0x6E, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC6, 0xC6, 0xCC, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0xCC, 0xC6, 0xC6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC6, 0xEE, 0xEE, 0xFE, 0xD6, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC6, 0xC6, 0xE6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xCE, 0xC6, 0xC6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0C, 0x06, 0x00,
	0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0xEE, 0xEE, 0xC6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x3C, 0x66, 0xC3, 0xC3, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC3, 0xC3, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7E, 0x06, 0x06, 0x0C, 0x0C, 0x18, 0x30, 0x30, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00,
	0xC0, 0xC0, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0C, 0x0C, 0x06, 0x06, 0x03, 0x03, 0x00, 0x00,
	0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00,
	0x00, 0x10, 0x38, 0x6C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
	0x00, 0x18, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x06, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x7E, 0x60, 0x60, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1E, 0x30, 0x30, 0x30, 0x7E, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x7C,
	0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x78,
	0x00, 0x00, 0x60, 0x60, 0x60, 0x60, 0x66, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x06,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x60, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x60, 0x60, 0x3C, 0x06, 0x06, 0x7C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x7E, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0x7C, 0x6C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF0, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00,
	0x00, 0xE0, 0x30, 0x30, 0x30, 0x30, 0x30, 0x1E, 0x30, 0x30, 0x30, 0x30, 0x30, 0xE0, 0x00, 0x00,
	0x00, 0x72, 0xD6, 0x9C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xAE, 0xAE, 0xA4, 0xA4, 0xC4, 0xC4, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0xAA, 0xAA, 0xEA, 0xEA, 0x0A, 0x0A, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xE4, 0xE4, 0xAC, 0xAC, 0xE4, 0xE4, 0x04, 0x04, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0xA2, 0xA2, 0xEE, 0xEE, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0xA2, 0xA2, 0xEE, 0xEE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x40, 0x40, 0x4E, 0x4E, 0x4A, 0x4A, 0xEA, 0xEA, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEE, 0xEE, 0x28, 0x28, 0xEE, 0xEE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCE, 0xCE, 0x88, 0x88, 0xEE, 0xEE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xA0, 0xA0, 0xA0, 0xA0, 0xEE, 0xEE, 0xA8, 0xA8, 0xAE, 0xAE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xA0, 0xA0, 0xA0, 0xA0, 0xE2, 0xE2, 0xA2, 0xA2, 0xA2, 0xA2, 0x0A, 0x0A, 0x0E, 0x0E, 0x00, 0x00,
	0xA0, 0xA0, 0xA0, 0xA0, 0xAE, 0xAE, 0xA8, 0xA8, 0x4E, 0x4E, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEC, 0xEC, 0x8A, 0x8A, 0x8A, 0x8A, 0x0A, 0x0A, 0x0C, 0x0C, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEA, 0xEA, 0x8A, 0x8A, 0x8A, 0x8A, 0x0A, 0x0A, 0x0E, 0x0E, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xCE, 0xCE, 0xA4, 0xA4, 0xA4, 0xA4, 0x04, 0x04, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEE, 0xEE, 0x22, 0x22, 0xEE, 0xEE, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEE, 0xEE, 0x22, 0x22, 0xE6, 0xE6, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xC0, 0xC0, 0xA0, 0xA0, 0xAE, 0xAE, 0xA8, 0xA8, 0xC8, 0xC8, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xE4, 0xE4, 0x8C, 0x8C, 0x84, 0x84, 0x04, 0x04, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0x82, 0x82, 0x8E, 0x8E, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEE, 0xEE, 0x28, 0x28, 0xEC, 0xEC, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0x8E, 0x8E, 0x88, 0x88, 0xE8, 0xE8, 0x08, 0x08, 0x0E, 0x0E, 0x00, 0x00,
	0xA0, 0xA0, 0xE0, 0xE0, 0xEA, 0xEA, 0xAA, 0xAA, 0xAE, 0xAE, 0x0E, 0x0E, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEE, 0xEE, 0x2A, 0x2A, 0xEE, 0xEE, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xCE, 0xCE, 0x8A, 0x8A, 0xEE, 0xEE, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0x2A, 0x2A, 0xEE, 0xEE, 0x0A, 0x0A, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0x2A, 0x2A, 0xEE, 0xEE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0x2A, 0x2A, 0xEE, 0xEE, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0x8E, 0x8E, 0x88, 0x88, 0xEE, 0xEE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0x80, 0x80, 0xEE, 0xEE, 0x24, 0x24, 0xE4, 0xE4, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xAE, 0xAE, 0xA8, 0xA8, 0xEE, 0xEE, 0x02, 0x02, 0x0E, 0x0E, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEA, 0xEA, 0x8E, 0x8E, 0x8E, 0x8E, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00,
	0xE0, 0xE0, 0xA0, 0xA0, 0xEE, 0xEE, 0xAA, 0xAA, 0xAE, 0xAE, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x60, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x6C, 0x6C, 0x60, 0x60, 0xF0, 0x60, 0x60, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC3, 0xC3, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00,
	0x00, 0x3C, 0x66, 0x60, 0x30, 0x38, 0x6C, 0x66, 0x36, 0x1C, 0x0C, 0x06, 0x66, 0x3C, 0x00, 0x00,
	0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x42, 0x81, 0x9D, 0xB1, 0xB1, 0xB1, 0x9D, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x3C, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x42, 0x81, 0xB9, 0xA5, 0xB9, 0xA5, 0xA5, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00,
	0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3C, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x6C, 0x0C, 0x18, 0x30, 0x60, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x6C, 0x0C, 0x38, 0x0C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0C, 0x0C, 0x18, 0x18, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xC0,
	0x00, 0x00, 0x3E, 0x7A, 0x7A, 0x7A, 0x7A, 0x3A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x06, 0x1C,
	0x00, 0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x40, 0xC6, 0x46, 0x4C, 0x4C, 0x18, 0x18, 0x30, 0x30, 0x62, 0x66, 0xCA, 0xCF, 0x02, 0x00,
	0x00, 0x40, 0xC6, 0x46, 0x4C, 0x4C, 0x18, 0x18, 0x30, 0x30, 0x6C, 0x62, 0xC4, 0xC8, 0x0E, 0x00,
	0x00, 0xC0, 0x26, 0x66, 0x2C, 0xCC, 0x18, 0x18, 0x30, 0x30, 0x62, 0x66, 0xCA, 0xCF, 0x02, 0x00,
	0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x30, 0x30, 0x60, 0x60, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x30, 0x18, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x0C, 0x18, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x18, 0x66, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x76, 0xDC, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x3C, 0x66, 0x3C, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3F, 0x7C, 0xFC, 0xCC, 0xCC, 0xFE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCF, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x66, 0x60, 0x60, 0x60, 0x60, 0x60, 0x66, 0x66, 0x3C, 0x0C, 0x06, 0x1C,
	0x30, 0x18, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x0C, 0x18, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x18, 0x66, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x00, 0x7E, 0x60, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00, 0x00,
	0x30, 0x18, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00,
	0x0C, 0x18, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00,
	0x18, 0x66, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x78, 0x6C, 0x66, 0x66, 0x66, 0xF6, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00, 0x00, 0x00,
	0x76, 0xDC, 0x00, 0xC6, 0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
	0x30, 0x18, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x0C, 0x18, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x18, 0x66, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x76, 0xDC, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x82, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3E, 0x66, 0x6E, 0x6E, 0x6E, 0x7E, 0x76, 0x76, 0x76, 0x66, 0x7C, 0x00, 0x00, 0x00,
	0x30, 0x18, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x0C, 0x18, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x18, 0x66, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x0C, 0x18, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0xD8, 0xCC, 0xC6, 0xC6, 0xC6, 0xC6, 0xCC, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0C, 0x18, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x66, 0x3C, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x1B, 0x1B, 0x7F, 0xD8, 0xD8, 0x77, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x0C, 0x06, 0x1C,
	0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x7E, 0x60, 0x60, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0C, 0x18, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x7E, 0x60, 0x60, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x7E, 0x60, 0x60, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x7E, 0x60, 0x60, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0C, 0x18, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x36, 0x1C, 0x1C, 0x36, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0C, 0x18, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0xBC, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0C, 0x18, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x3C, 0x66, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0C, 0x18, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x3C,
	0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60,
	0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x3C,
};

inline static FColor AddWarped(FColor A, FColor B)
{
	return FColor(A.R() + B.R(), A.G() + B.G(), A.B() + B.B());
}

void PrintLine(
	const FVideo& Video,
	const FVideoViewPort& ViewPort,
	const FVec2& Pos,
	FColor Color,
	FColor Gradient,
	EFont Font,
	const char* Fmt,
	...)
{
	va_list Args;
	va_start(Args, Fmt);


	const uint8_t* FontTable = nullptr;
	int Width = 0;
	int Height = 0;

	switch (Font)
	{
	case EFont::Unscii8x16:
		FontTable = &Unscii8x16[0][0];
		Width = 8;
		Height = 16;
		break;
	default: assert(0);
	}

	const int YI = static_cast<int>(Pos.Y);
	const int YBegin = std::max(YI, ViewPort.Y);
	const int YEnd = std::min(YI + Height, ViewPort.Y + ViewPort.Height);
	if (YEnd - YBegin <= 0)
		return;

	constexpr size_t N = 256;
	char Buf[N];
	vsnprintf(Buf, N, Fmt, Args);
	Buf[N - 1] = '\0';

	const int CharCount = static_cast<int>(strlen(Buf));
	if (CharCount == 0)
		return;

	const int TotalBitWidth = CharCount * Width;

	const int XI = static_cast<int>(Pos.X);
	const int XBegin = std::max(XI, ViewPort.X);
	const int XEnd = std::min(XI + TotalBitWidth, ViewPort.X + ViewPort.Width);
	if (XEnd - XBegin <= 0)
		return;

	const int BeginBit = -std::min(0, XI - ViewPort.X);
	const int EndBit = BeginBit + XEnd - XBegin;
	const int FirstCharIndex = BeginBit / Width;
	const int LastCharIndex = (EndBit - 1) / Width;

	uint8_t Mask[N];
	memset(Mask, uint8_t{0xff}, static_cast<size_t>(LastCharIndex) - FirstCharIndex + 1);

	Mask[0] = (uint8_t{1} << (Width - (BeginBit % Width))) - 1;
	if (EndBit % Width != 0)
		Mask[LastCharIndex - FirstCharIndex] &= ~((uint8_t{1} << (Width - (EndBit % Width))) - 1);

	const char* BeginChar = &Buf[FirstCharIndex];
	const char* EndChar = &Buf[LastCharIndex + 1];

	FColor RowColor = Color;
	for (int i = 0; i < YBegin - YI; ++i)
	{
		RowColor = AddWarped(RowColor, Gradient);
	}

	for (int Y = YBegin; Y < YEnd; ++Y)
	{
		const int Row = Y - YI;
		const char* Char = BeginChar;
		const uint8_t* CurrentMask = Mask;
		FColor* ColorBuf = &Video.Buffer[Y * Video.Width + XBegin - BeginBit % Width];
		do
		{
			uint8_t Bits = Unscii8x16[*Char++][Row] & *CurrentMask++;
			for (int i = 0; i < Width; ++i)
			{
				if (Bits & 0x80u)
				{
					*ColorBuf = RowColor;
				}
				ColorBuf++;
				Bits <<= 1;
			}
		} while (Char < EndChar);
		RowColor = AddWarped(RowColor, Gradient);
	}

	va_end(Args);
}


template <typename T> T* AdvanceBytes(T* Ptr, size_t Count)
{
	return (T*)((uint8_t*)Ptr + Count);
}

void Dots(const FVideo& Video, const FVideoViewPort& ViewPort, const FViewportTransform& Transform, size_t Count, const FVec2* Positions, size_t PositionStride, const float* Sizes, size_t SizeStride, const FColor* Colors, size_t ColorStride)
{
	const FVec2* PositionPtr = Positions;
	const float* SizePtr = Sizes;
	const FColor* ColorPtr = Colors;
	for (auto i = 0u; i < Count; ++i)
	{
		const auto Pos = FVec2Fixed(Transform.WorldToViewport(*PositionPtr));
		const auto Size = FFixed((*SizePtr * Transform.Scale + 0.5f) / 2.0f);
		const auto Begin = Max(FVec2Fixed(FFixed::From(ViewPort.X), FFixed::From(ViewPort.Y)), Pos - Size);
		const auto End = Min(FVec2Fixed(FFixed::From(ViewPort.X + ViewPort.Width), FFixed::From(ViewPort.Y + ViewPort.Height)), Pos + Size + FFixed::One());
		const auto XBegin = Center(Begin.X);
		const auto XEnd = Center(End.X);
		const auto PixelWidth = ((XEnd - XBegin).V >> FFixed::BITS);
		const auto YBegin = Center(Begin.Y);
		const auto YEnd = Center(End.Y);
		const auto PixelHeight = ((YEnd - YBegin).V >> FFixed::BITS);
		if (PixelWidth > 0 && PixelHeight > 0)
		{
			const auto Color = *ColorPtr;
			const FFixed AccXStep = -Pos.X * FFixed::From(2) - FFixed::One();
			const FFixed AccYStep = -Pos.Y * FFixed::From(2) - FFixed::One();
			auto AccY = SquaredDistance(FVec2Fixed(XBegin, YBegin), Pos) - Size * Size;
			const int Px = XBegin.V >> FFixed::BITS;
			const int Py = YBegin.V >> FFixed::BITS;
			FColor* BufBase = &Video.Buffer[Px + Py * Video.Width];
			const FColor* BufBaseEnd = BufBase + (size_t)PixelHeight * Video.Width;
			auto Y = YBegin;
			for (;;)
			{
				auto AccX = AccY;
				FColor* Buf = BufBase;
				const FColor* BufEnd = Buf + PixelWidth;
				auto X = XBegin;
				for (;;)
				{
					if (AccX < FFixed::Zero())
						*Buf = Color;
					if (++Buf == BufEnd)
						break;
					X = X + FFixed::One();
					AccX = AccX + X + X + AccXStep;
				}

				BufBase += Video.Width;
				if (BufBase == BufBaseEnd)
					break;
				Y = Y + FFixed::One();
				AccY = AccY + Y + Y + AccYStep;
			}
		}
		PositionPtr = AdvanceBytes(PositionPtr, PositionStride);
		SizePtr = AdvanceBytes(SizePtr, SizeStride);
		ColorPtr = AdvanceBytes(ColorPtr, ColorStride);
	}
}

void Circles(const FVideo& Video, const FVideoViewPort& ViewPort, const FViewportTransform& Transform, size_t Count, const FVec2* Positions, size_t PositionStride, const float* Sizes, size_t SizeStride, const FColor* Colors, size_t ColorStride, const float* Thicknesses, size_t ThicknessStride)
{
	const FVec2* PositionPtr = Positions;
	const float* SizePtr = Sizes;
	const FColor* ColorPtr = Colors;
	const float* ThicknessPtr = Thicknesses;
	for (auto i = 0u; i < Count; ++i)
	{
		const auto Pos = FVec2Fixed(Transform.WorldToViewport(*PositionPtr));
		const auto Size = FFixed((*SizePtr * Transform.Scale + 0.5f) / 2.0f);
		const auto SizeInner = FFixed((std::max(0.0f, (*SizePtr - *ThicknessPtr) * Transform.Scale) + 0.5f) / 2.0f);
		const auto Begin = Max(FVec2Fixed(FFixed::From(ViewPort.X), FFixed::From(ViewPort.Y)), Pos - Size);
		const auto End = Min(FVec2Fixed(FFixed::From(ViewPort.X + ViewPort.Width), FFixed::From(ViewPort.Y + ViewPort.Height)), Pos + Size + FFixed::One());
		const auto XBegin = Center(Begin.X);
		const auto XEnd = Center(End.X);
		const auto PixelWidth = ((XEnd - XBegin).V >> FFixed::BITS);
		const auto YBegin = Center(Begin.Y);
		const auto YEnd = Center(End.Y);
		const auto PixelHeight = ((YEnd - YBegin).V >> FFixed::BITS);
		if (PixelWidth > 0 && PixelHeight > 0)
		{
			const auto Color = *ColorPtr;
			const FFixed AccXStep = -Pos.X * FFixed::From(2) - FFixed::One();
			const FFixed AccYStep = -Pos.Y * FFixed::From(2) - FFixed::One();
			auto AccY = SquaredDistance(FVec2Fixed(XBegin, YBegin), Pos) - Size * Size;
			auto InnerDelta = SquaredDistance(FVec2Fixed(XBegin, YBegin), Pos) - SizeInner * SizeInner - AccY;
			const int Px = XBegin.V >> FFixed::BITS;
			const int Py = YBegin.V >> FFixed::BITS;
			FColor* BufBase = &Video.Buffer[Px + Py * Video.Width];
			const FColor* BufBaseEnd = BufBase + (size_t)PixelHeight * Video.Width;
			auto Y = YBegin;
			for (;;)
			{
				auto AccX = AccY;
				FColor* Buf = BufBase;
				const FColor* BufEnd = Buf + PixelWidth;
				auto X = XBegin;
				for (;;)
				{
					const auto AccXInner = AccX + InnerDelta;
					//if (AccX < FFixed::Zero() && !(AccXInner < FFixed::Zero())) 
					if ((AccX.V & ~AccXInner.V) < 0) // equivalent to the line above
						*Buf = Color;
					if (++Buf == BufEnd)
						break;
					X = X + FFixed::One();
					AccX = AccX + X + X + AccXStep;
				}

				BufBase += Video.Width;
				if (BufBase == BufBaseEnd)
					break;
				Y = Y + FFixed::One();
				AccY = AccY + Y + Y + AccYStep;
			}
		}
		PositionPtr = AdvanceBytes(PositionPtr, PositionStride);
		SizePtr = AdvanceBytes(SizePtr, SizeStride);
		ColorPtr = AdvanceBytes(ColorPtr, ColorStride);
		ThicknessPtr = AdvanceBytes(ThicknessPtr, ThicknessStride);
	}
}

void Pixels(
	const FVideo& Video,
	const FVideoViewPort& ViewPort,
	const FViewportTransform& Transform,
	size_t Count,
	const FVec2* Positions,
	size_t PositionStride,
	const FColor* Colors,
	size_t ColorStride)
{
	const FVec2* PositionPtr = Positions;
	const FColor* ColorPtr = Colors;
	const auto XBegin = FFixed::From(ViewPort.X);
	const auto XEnd = FFixed::From(ViewPort.X + ViewPort.Width);
	const auto YBegin = FFixed::From(ViewPort.Y);
	const auto YEnd = FFixed::From(ViewPort.Y + ViewPort.Height);
	for (auto i = 0u; i < Count; ++i)
	{
		const auto Pos = FVec2Fixed(Transform.WorldToViewport(*PositionPtr));
		if (XBegin <= Pos.X && Pos.X < XEnd && YBegin <= Pos.Y && Pos.Y < YEnd)
		{
			const int Px = Pos.X.V >> FFixed::BITS;
			const int Py = Pos.Y.V >> FFixed::BITS;
			Video.Buffer[Px + Py * Video.Width] = *ColorPtr;
		}

		PositionPtr = AdvanceBytes(PositionPtr, PositionStride);
		ColorPtr = AdvanceBytes(ColorPtr, ColorStride);
	}
}

#if _MSC_VER
/*
 __          ___       ____ ___
 \ \        / (_)     |___ \__ \
  \ \  /\  / / _ _ __   __) | ) |
   \ \/  \/ / | | '_ \ |__ < / /
	\  /\  /  | | | | |___) / /_
	 \/  \/   |_|_| |_|____/____|
*/

#define WIN32_LEAN_AND_MEAN
#pragma warning(push, 3)
#include <windows.h>
#include <shellscalingapi.h>
#include <audioclient.h>
#include <mmdeviceapi.h>
#pragma warning(pop)

#pragma comment(lib, "Shcore.lib")
#pragma comment(lib, "Gdi32.lib")
#pragma comment(lib, "Ole32.lib")
#pragma comment(lib, "User32.lib")

namespace Engine_Win32
{

	struct FWindowData
	{
		int Width, Height;

		int BufferWidth, BufferHeight;
		void* Buffer;

		// Audio Data prepared by the audio thread before the audio event is signaled
		int SampleRate;
		FAudioRingBuffer AudioRingBuffer;

		HANDLE AudioThreadHandles[2];
		std::atomic_bool QuitAudio;
		DWORD AudioThreadId;
		HWND Wnd;
		BITMAPINFO* Bitmap;
	};

	DWORD WINAPI AudioThread(LPVOID Param)
	{
		auto WindowData = (FWindowData*)Param;
		const CLSID TNP_CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
		const IID TNP_IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
		const IID TNP_IID_IAudioClient = __uuidof(IAudioClient);
		const IID TNP_IID_IAudioRenderClient = __uuidof(IAudioRenderClient);
		const GUID IeeeFloatSubformatGuid = { STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT };

		// Set up all the interfaces etc. If anything fails, just return 1 and we won't have audio.
		if (HRESULT Hr = CoInitialize(NULL); FAILED(Hr))
			return 1;

		IMMDeviceEnumerator* Enumerator = NULL;
		if (HRESULT Hr = CoCreateInstance(TNP_CLSID_MMDeviceEnumerator, NULL, CLSCTX_ALL, TNP_IID_IMMDeviceEnumerator, (void**)&Enumerator); FAILED(Hr))
			return 1;

		IMMDevice* Device = NULL;
		if (HRESULT Hr = Enumerator->GetDefaultAudioEndpoint(eRender, eConsole, &Device); FAILED(Hr))
			return 1;

		IAudioClient* AudioClient = NULL;
		if (HRESULT Hr = Device->Activate(TNP_IID_IAudioClient, CLSCTX_ALL, NULL, (void**)&AudioClient); FAILED(Hr))
			return 1;

		// Setup for a stereo, 48kHz, float format
		const WORD BitResolution = 32;
		const DWORD SampleRate = 48000;

		WAVEFORMATEXTENSIBLE Wave;
		ZeroMemory(&Wave, sizeof(Wave));
		Wave.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
		Wave.Format.cbSize = 22;
		Wave.Format.nChannels = 2;
		Wave.Format.nSamplesPerSec = SampleRate;
		Wave.Format.wBitsPerSample = BitResolution;
		Wave.Samples.wValidBitsPerSample = BitResolution;
		Wave.Format.nBlockAlign = 2 * (BitResolution / 8);
		Wave.dwChannelMask = 3;
		CopyMemory(&Wave.SubFormat, &IeeeFloatSubformatGuid, sizeof(GUID));
		Wave.Format.nAvgBytesPerSec = SampleRate * Wave.Format.nBlockAlign;

		WAVEFORMATEXTENSIBLE* ClosestMatch = NULL;
		if (HRESULT Hr = AudioClient->IsFormatSupported(AUDCLNT_SHAREMODE_SHARED, (WAVEFORMATEX*)&Wave, (WAVEFORMATEX**)&ClosestMatch); Hr != S_OK)
			return 1;

		REFERENCE_TIME MinimumDevicePeriod;
		if (HRESULT Hr = AudioClient->GetDevicePeriod(0, &MinimumDevicePeriod); FAILED(Hr))
			return 1;

		// Init the device to desired bit rate and resolution
		if (HRESULT Hr = AudioClient->Initialize(AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_EVENTCALLBACK, MinimumDevicePeriod, MinimumDevicePeriod, (WAVEFORMATEX*)&Wave, 0); FAILED(Hr))
			return 1;

		HANDLE WasapiEvent = CreateEvent(0, 0, 0, 0);
		if (WasapiEvent == NULL)
			return 1;

		if (HRESULT Hr = AudioClient->SetEventHandle(WasapiEvent); FAILED(Hr))
			return 1;

		UINT32 NumBufferFrames = 0;
		if (HRESULT Hr = AudioClient->GetBufferSize(&NumBufferFrames); FAILED(Hr))
			return 1;

		IAudioRenderClient* AudioRenderClient = NULL;
		if (HRESULT Hr = AudioClient->GetService(TNP_IID_IAudioRenderClient, (void**)&AudioRenderClient); FAILED(Hr))
			return 1;

		// Initialize with silence
		BYTE* Data = nullptr;
		if (HRESULT Hr = AudioRenderClient->GetBuffer(NumBufferFrames, &Data); FAILED(Hr))
			return 1;

		if (HRESULT Hr = AudioRenderClient->ReleaseBuffer(NumBufferFrames, AUDCLNT_BUFFERFLAGS_SILENT); FAILED(Hr))
			return 1;

		// AvSetMmThreadCharacteristics(_T("Pro Audio"), &Index))) ?

		if (HRESULT Hr = AudioClient->Start(); FAILED(Hr))
			return 1;

		WindowData->SampleRate = SampleRate;
		WindowData->AudioRingBuffer.Initialize(WindowData->SampleRate / 10, WindowData->SampleRate);

		SetEvent(WindowData->AudioThreadHandles[0]);

		while (!WindowData->QuitAudio)
		{
			WaitForSingleObject(WasapiEvent, INFINITE);

			UINT32 CurrentPadding = 0;
			if (HRESULT Hr = AudioClient->GetCurrentPadding(&CurrentPadding); FAILED(Hr))
				return 1;

			auto AvailableBufferFrames = NumBufferFrames - CurrentPadding;
			const auto ReadRange = WindowData->AudioRingBuffer.GetReadRange(AvailableBufferFrames);

			Data = nullptr;
			if (HRESULT Hr = AudioRenderClient->GetBuffer(ReadRange.TotalLength(), &Data); FAILED(Hr))
				return 1;

			if (Data)
				WindowData->AudioRingBuffer.InterleavedReadInto((float*)Data, ReadRange);

			if (HRESULT Hr = AudioRenderClient->ReleaseBuffer(ReadRange.TotalLength(), 0); FAILED(Hr))
				return 1;
		}

		// Don't really care about cleaning up, since we're shutting down the process.
		return 0;
	}

	LRESULT CALLBACK WndProc(HWND Wnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	{
		LRESULT res = 0;

		auto WindowData = (FWindowData*)GetWindowLongPtr(Wnd, GWLP_USERDATA);

		switch (Msg)
		{
		case WM_PAINT:
		{
			if (WindowData && WindowData->Buffer)
			{
				StretchDIBits(GetDC(Wnd), 0, 0, WindowData->Width, WindowData->Height, 0, 0, WindowData->BufferWidth, WindowData->BufferHeight, WindowData->Buffer, WindowData->Bitmap, DIB_RGB_COLORS, SRCCOPY);
			}
			ValidateRect(Wnd, 0x0);
		} break;

		case WM_DESTROY:
		case WM_CLOSE:
		{
			PostQuitMessage(0);
		} break;

		default:
		{
			res = DefWindowProc(Wnd, Msg, wParam, lParam);
		} break;
		}

		return res;
	}

	int __stdcall WinMain(HINSTANCE Instance, HINSTANCE PrevInstance, LPSTR, int)
	{
		auto WindowData = std::make_unique<FWindowData>();

		const int PixelScale = 2;

		WindowData->BufferWidth = 1920 / PixelScale;
		WindowData->BufferHeight = 1080 / PixelScale;
		WindowData->Width = PixelScale * WindowData->BufferWidth;
		WindowData->Height = PixelScale * WindowData->BufferHeight;

		WindowData->AudioThreadHandles[0] = CreateEvent(0, 0, 0, 0); // Audio ready event
		WindowData->AudioThreadHandles[1] = CreateThread(NULL, 0, AudioThread, WindowData.get(), 0, &WindowData->AudioThreadId);

		auto WindowClassName = TEXT("MainWndClass");

		SetProcessDpiAwareness(PROCESS_SYSTEM_DPI_AWARE);

		if (!PrevInstance)
		{
			WNDCLASS Wc{};
			Wc.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW;
			Wc.lpfnWndProc = (WNDPROC)WndProc;
			Wc.hInstance = Instance;
			Wc.hIcon = LoadIcon((HINSTANCE)NULL, IDI_APPLICATION);
			Wc.hCursor = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
			Wc.lpszClassName = WindowClassName;

			if (!RegisterClass(&Wc))
				return 1;
		}

		auto WindowStyle = WS_OVERLAPPEDWINDOW & ~WS_MAXIMIZEBOX & ~WS_THICKFRAME;
		RECT WindowRect{};
		WindowRect.right = WindowData->Width;
		WindowRect.bottom = WindowData->Height;
		AdjustWindowRect(&WindowRect, WindowStyle, 0);

		WindowData->Wnd = CreateWindowEx(0, WindowClassName, TEXT("Embark Worms"), WindowStyle, CW_USEDEFAULT, CW_USEDEFAULT, WindowRect.right - WindowRect.left, WindowRect.bottom - WindowRect.top, 0, 0, 0, 0);
		if (!WindowData->Wnd)
			return 1;

		SetWindowLongPtr(WindowData->Wnd, GWLP_USERDATA, (LONG_PTR)WindowData.get());

		ShowWindow(WindowData->Wnd, SW_NORMAL);

		std::unique_ptr<BITMAPINFO, void(*)(void*)> BitmapData{ (BITMAPINFO*)calloc(1, sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 3), [](void* p) { free(p); } };

		WindowData->Bitmap = BitmapData.get();
		if (WindowData->Bitmap == 0x0)
		{
			return 1;
		}

		WindowData->Bitmap->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
		WindowData->Bitmap->bmiHeader.biPlanes = 1;
		WindowData->Bitmap->bmiHeader.biBitCount = 32;
		WindowData->Bitmap->bmiHeader.biCompression = BI_BITFIELDS;
		WindowData->Bitmap->bmiHeader.biWidth = WindowData->BufferWidth;
		WindowData->Bitmap->bmiHeader.biHeight = -WindowData->BufferHeight;
		WindowData->Bitmap->bmiColors[0].rgbRed = 0xff;
		WindowData->Bitmap->bmiColors[1].rgbGreen = 0xff;
		WindowData->Bitmap->bmiColors[2].rgbBlue = 0xff;

		std::unique_ptr<FColor, void(*)(void*)> VideoBuffer{ (FColor*)calloc(1, sizeof(FColor) * WindowData->BufferWidth * WindowData->BufferHeight), [](void* p) { free(p); } };
		FVideo Video{ WindowData->BufferWidth, WindowData->BufferHeight, VideoBuffer.get() };
		WindowData->Buffer = Video.Buffer;

		bool HaveAudio = WaitForMultipleObjects(2, WindowData->AudioThreadHandles, FALSE, INFINITE) == WAIT_OBJECT_0;
		(void)HaveAudio;

		std::vector<float> LChannelBuffer(WindowData->AudioRingBuffer.PerChannelBufferLength());
		std::vector<float> RChannelBuffer(WindowData->AudioRingBuffer.PerChannelBufferLength());


		FAudio Audio{ WindowData->SampleRate, 0, LChannelBuffer.data(), RChannelBuffer.data() };

		FTime Time{};

		int64_t PerformanceFrequency = 0;
		int64_t FrameStartTime = 0;
		QueryPerformanceFrequency((LARGE_INTEGER*)&PerformanceFrequency);
		QueryPerformanceCounter((LARGE_INTEGER*)&FrameStartTime);

		FInput Input{};

		const size_t DeltasCount = 60;
		double Deltas[DeltasCount] = { 0.0 };
		int DeltaIndex = 0;

		for (;;)
		{
			MSG Msg;
			while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE))
			{
				if (Msg.message == WM_QUIT)
					goto DoQuit;
				TranslateMessage(&Msg);
				DispatchMessage(&Msg);
			}

			auto AudioRange = WindowData->AudioRingBuffer.GetWriteRange(int(Time.DeltaTime * WindowData->SampleRate));
			Audio.SamplesToWrite = AudioRange.TotalLength();

			POINT Point;
			GetCursorPos(&Point);
			ScreenToClient(WindowData->Wnd, &Point);
			Input.Left = (GetKeyState(VK_LEFT) < 0) || (GetKeyState('A') < 0);
			Input.Right = (GetKeyState(VK_RIGHT) < 0) || (GetKeyState('D') < 0);
			Input.Up = (GetKeyState(VK_UP) < 0) || (GetKeyState('W') < 0);
			Input.Down = (GetKeyState(VK_DOWN) < 0) || (GetKeyState('S') < 0);
			Input.ActionButton0 = (GetKeyState('Z') < 0) || (GetKeyState(VK_SPACE) < 0) || (GetKeyState(VK_LBUTTON) < 0);
			Input.ActionButton1 = (GetKeyState('X') < 0) || (GetKeyState('E') < 0) || (GetKeyState(VK_RBUTTON) < 0);
			Input.Escape = (GetKeyState(VK_ESCAPE) < 0);
			Input.MousePos.X = (float)(Point.x / PixelScale);
			Input.MousePos.Y = (float)(Point.y / PixelScale);

			if (!GameUpdate(Video, Audio, Input, Time))
			{
				goto DoQuit;
			}

			WindowData->AudioRingBuffer.Write(Audio, AudioRange);

			InvalidateRect(WindowData->Wnd, 0x0, TRUE);
			SendMessage(WindowData->Wnd, WM_PAINT, 0, 0);

			// Update Time
			int64_t FrameEndTime = 0;
			QueryPerformanceCounter((LARGE_INTEGER*)&FrameEndTime);
			Time.DeltaTime = (double)(FrameEndTime - FrameStartTime) / (double)PerformanceFrequency;
			if (Time.DeltaTime > 1.0 / 30.0)
			{
				Time.DeltaTime = 1.0 / 30.0; // Clamp, e.g. when debugging
			}

			Time.ElapsedTime += Time.DeltaTime;
			FrameStartTime = FrameEndTime;

			Deltas[DeltaIndex++] = Time.DeltaTime;
			if (DeltaIndex == DeltasCount)
			{
				DeltaIndex = 0;
				auto Average = std::accumulate(std::begin(Deltas), std::end(Deltas), 0.0) / (double)DeltasCount;
				char Log[256];
				sprintf_s(Log, "Fps: %f, Delta: %f\n", 1.0 / Average, Average);
				OutputDebugStringA(Log);
			}
		}
	DoQuit:
		// Join in on the audio thread
		WindowData->QuitAudio = true;
		WaitForSingleObject(WindowData->AudioThreadHandles[1], 1000);
		return 0;
	}

}

int WINAPI WinMain(_In_ HINSTANCE Instance, _In_opt_ HINSTANCE PrevInstance, _In_ LPSTR Cmdline, _In_ int Show)
{
	return Engine_Win32::WinMain(Instance, PrevInstance, Cmdline, Show);
}


#else

#include <sys/ipc.h>
#include <sys/shm.h>

#include <alsa/asoundlib.h>

#include <xcb/xcb.h>
#include <xcb/shm.h>
#include <xcb/xcb_icccm.h>
#include <xcb/xcb_image.h>
#include <xkbcommon/xkbcommon.h>
#include <xkbcommon/xkbcommon-x11.h>

#include <thread>
#include <future>

namespace Engine_XCB
{

struct FWindowData
{
	int Width, Height;

	int BufferWidth, BufferHeight;
	void* Buffer;

	// Audio Data prepared by the audio thread before the audio event is signaled
	int SampleRate;
	FAudioRingBuffer AudioRingBuffer;
	std::atomic_bool QuitAudio;

	xcb_connection_t* Connection;
	xcb_image_t* Image;
	xcb_drawable_t WindowId;
	xcb_pixmap_t PixmapId;
	xcb_gcontext_t ContextId;
	xcb_generic_event_t* Event;
	xcb_atom_t CloseAtom;

	xkb_context* KbdContext;
	xkb_state* KbdState;
	xkb_keymap* Keymap;
};

double QueryTime()
{
	const int64_t NanoSecPerSec = 1000000000L;
	struct timespec Ts;
	if (clock_gettime(CLOCK_MONOTONIC_RAW, &Ts) != 0)
	{
		fprintf(stderr, "Failed to get time");
		return -1.0;
	}
	return (double)(Ts.tv_nsec + Ts.tv_sec * NanoSecPerSec) / 1000000000.0;
}

int InitWindow(std::unique_ptr<FWindowData>& WindowData)
{
	// connect and grab first screen
	xcb_connection_t* Connection = xcb_connect(nullptr, nullptr);
	WindowData->Connection = Connection;
	const xcb_screen_t* Screen = xcb_setup_roots_iterator(xcb_get_setup(Connection)).data;

	// generate ids for needed items
	WindowData->WindowId = xcb_generate_id(Connection);
	WindowData->PixmapId = xcb_generate_id(Connection);
	WindowData->ContextId = xcb_generate_id(Connection);

	// select window flags & create window
	uint32_t WindowMask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK;
	uint32_t ValueMask = XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS | XCB_EVENT_MASK_BUTTON_RELEASE | XCB_EVENT_MASK_POINTER_MOTION | XCB_EVENT_MASK_BUTTON_MOTION |
						 XCB_EVENT_MASK_KEY_PRESS |XCB_EVENT_MASK_KEY_RELEASE | XCB_EVENT_MASK_STRUCTURE_NOTIFY;
	uint32_t Values[] = { Screen->black_pixel, ValueMask };

	xcb_create_window(Connection, Screen->root_depth, WindowData->WindowId, Screen->root,
						0, 0, WindowData->BufferWidth, WindowData->BufferHeight, 1,
						XCB_WINDOW_CLASS_INPUT_OUTPUT, Screen->root_visual,	WindowMask, Values);

	// disable resizing
	xcb_size_hints_t SizeHints;
	SizeHints.flags = XCB_ICCCM_SIZE_HINT_P_MIN_SIZE | XCB_ICCCM_SIZE_HINT_P_MAX_SIZE;
	SizeHints.min_width = SizeHints.max_width = WindowData->BufferWidth;
	SizeHints.min_height = SizeHints.max_height = WindowData->BufferHeight;
	xcb_icccm_set_wm_normal_hints(Connection, WindowData->WindowId, &SizeHints);

	// set window title and class
	const std::string AppTitle = "TinyPixelNoise";
	xcb_icccm_set_wm_class_checked(Connection, WindowData->WindowId, AppTitle.length(), AppTitle.c_str());
	xcb_change_property(Connection, XCB_PROP_MODE_REPLACE, WindowData->WindowId, XCB_ATOM_WM_NAME, XCB_ATOM_STRING, 8, AppTitle.length(), AppTitle.c_str());

	// create pixmap and image handle 
	xcb_create_pixmap(Connection, Screen->root_depth, WindowData->PixmapId, WindowData->WindowId, WindowData->BufferWidth, WindowData->BufferHeight);
	xcb_create_gc(Connection, WindowData->ContextId, WindowData->PixmapId, 0, nullptr);
	WindowData->Image = xcb_image_create_native(Connection, WindowData->BufferWidth, WindowData->BufferHeight, XCB_IMAGE_FORMAT_Z_PIXMAP, Screen->root_depth, WindowData->Buffer, WindowData->BufferWidth * WindowData->BufferHeight * 4, (uint8_t*)WindowData->Buffer);

	// query for close wm atoms
	static const std::string WmClose = "WM_DELETE_WINDOW";
	static const std::string WmProto = "WM_PROTOCOLS";

	xcb_intern_atom_cookie_t WmCloseAtomRequest = xcb_intern_atom(Connection, 0, WmClose.size(), WmClose.c_str());
	xcb_intern_atom_reply_t* WmCloseWindowAtomReply = xcb_intern_atom_reply(Connection, WmCloseAtomRequest, NULL);
	xcb_intern_atom_cookie_t WmProtoAtomRequest = xcb_intern_atom(Connection, 0, WmProto.size(), WmProto.c_str());
	xcb_intern_atom_reply_t* WmProtoAtomReply = xcb_intern_atom_reply(Connection, WmProtoAtomRequest, NULL);

	if (WmCloseWindowAtomReply != nullptr && WmProtoAtomReply != nullptr)
	{
		xcb_icccm_set_wm_protocols(Connection, WindowData->WindowId, WmProtoAtomReply->atom, 1, & WmCloseWindowAtomReply->atom);
		WindowData->CloseAtom = WmCloseWindowAtomReply->atom;
		free(WmCloseWindowAtomReply);
		free(WmProtoAtomReply);
	}

	// Finally map window to screen
	xcb_map_window(Connection, WindowData->WindowId);
	xcb_flush(Connection);

	// setup keyboard handling
	xkb_x11_setup_xkb_extension(Connection, XKB_X11_MIN_MAJOR_XKB_VERSION, XKB_X11_MIN_MINOR_XKB_VERSION, XKB_X11_SETUP_XKB_EXTENSION_NO_FLAGS, nullptr, nullptr, nullptr, nullptr);
	WindowData->KbdContext = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
	int32_t KbdDeviceId = xkb_x11_get_core_keyboard_device_id(Connection);
	WindowData->Keymap = xkb_x11_keymap_new_from_device(WindowData->KbdContext, Connection, KbdDeviceId, XKB_KEYMAP_COMPILE_NO_FLAGS);
	WindowData->KbdState = xkb_x11_state_new_from_device(WindowData->Keymap, Connection, KbdDeviceId);
	return 0;
}

void DestroyWindow(std::unique_ptr<FWindowData>& WindowData)
{
	xkb_state_unref(WindowData->KbdState);
	xkb_keymap_unref(WindowData->Keymap);
	xkb_context_unref(WindowData->KbdContext);
	xcb_free_gc(WindowData->Connection, WindowData->ContextId);
	xcb_free_pixmap(WindowData->Connection, WindowData->PixmapId);
	xcb_destroy_window(WindowData->Connection, WindowData->WindowId);

}

int Update(std::unique_ptr<FWindowData>& WindowData, FInput& Input)
{
	for (xcb_generic_event_t* Event = nullptr; (Event = xcb_poll_for_event(WindowData->Connection)); free(Event))
	{
		bool PressState = false;
		switch (Event->response_type & ~0x80)
		{
			case XCB_CLIENT_MESSAGE:
			{
				xcb_client_message_event_t* ClientEvent = reinterpret_cast<xcb_client_message_event_t*>(Event);
				if ((ClientEvent->format == 32) && (ClientEvent->data.data32[0]) == static_cast<long>(WindowData->CloseAtom))
				{
					goto Shutdown;
				}
				break;
			}

			case XCB_DESTROY_NOTIFY:
				goto Shutdown;
				break;

			case XCB_MOTION_NOTIFY:
			{
				xcb_motion_notify_event_t* Motion = reinterpret_cast<xcb_motion_notify_event_t*>(Event);
				Input.MousePos.X = (float) Motion->event_x;// / 2.0f;
				Input.MousePos.Y = (float) Motion->event_y;// / 2.0f;
				break;
			}

			case XCB_BUTTON_PRESS: 
			PressState = true;
			case XCB_BUTTON_RELEASE:
			{
				 xcb_button_press_event_t *Press = reinterpret_cast<xcb_button_press_event_t *>(Event);
				 switch (Press->detail)
				 {
					 case XCB_BUTTON_INDEX_1: Input.ActionButton0 = PressState; break;
					 case XCB_BUTTON_INDEX_3: Input.ActionButton1 = PressState; break;
				 }
				 break;
			}

			case XCB_KEY_PRESS: 
			PressState = true;
			case XCB_KEY_RELEASE:
			{
				xcb_key_press_event_t* Press = reinterpret_cast<xcb_key_press_event_t*>(Event);
				xkb_keysym_t Keysym = xkb_state_key_get_one_sym(WindowData->KbdState, Press->detail);
				switch (Keysym)
				{
					case XKB_KEY_Left: 	case XKB_KEY_A:	case XKB_KEY_a: Input.Left = PressState; 	break;
					case XKB_KEY_Right: case XKB_KEY_D:	case XKB_KEY_d:	Input.Right = PressState; 	break;
					case XKB_KEY_Up: 	case XKB_KEY_W:	case XKB_KEY_w:	Input.Up = PressState; 		break;
					case XKB_KEY_Down: 	case XKB_KEY_S:	case XKB_KEY_s:	Input.Down = PressState;	break;
					case XKB_KEY_Escape: 								goto Shutdown;				break;
				}
			break;
			}
		}
	}

	xcb_image_put(WindowData->Connection, WindowData->PixmapId, WindowData->ContextId, WindowData->Image, 0, 0, 0);
	xcb_copy_area(WindowData->Connection, WindowData->PixmapId, WindowData->WindowId, WindowData->ContextId,0,0,0,0,WindowData->BufferWidth, WindowData->BufferHeight);
	xcb_flush(WindowData->Connection);
	return 1;

Shutdown:
	DestroyWindow(WindowData);
	return 0;
}

void AudioThreadFunc(FWindowData* WindowData, std::promise<bool> InitBarrier)
{
	snd_pcm_t* PcmHandle = nullptr;
	snd_pcm_hw_params_t* PcmParams = nullptr;
	// fairly small buffers
	snd_pcm_uframes_t BufferFrames = 1024;

	// this will probably default to pulseaudio, your experience may vary a bit
	constexpr const char* PcmDevice = "default";
	const int Channels = 2;
	unsigned int SampleRate = 48000;
	int Result;

	std::unique_ptr<short, void(*)(void*)> AudioBuffer{ (short*)calloc(1, sizeof(float) * Channels * BufferFrames), [](void* p) { free(p); } };

	if ( (Result = snd_pcm_open(&PcmHandle, PcmDevice, SND_PCM_STREAM_PLAYBACK, 0)) < 0)
	{
		fprintf(stderr,"Failed to open device: %s, error: %s\n", PcmDevice, snd_strerror(Result));
		goto error_exit;
	}
	snd_pcm_hw_params_alloca(&PcmParams);
	snd_pcm_hw_params_any(PcmHandle, PcmParams);

	if (snd_pcm_hw_params_set_access(PcmHandle, PcmParams, SND_PCM_ACCESS_RW_INTERLEAVED) < 0) goto error_exit;
	if (snd_pcm_hw_params_set_format(PcmHandle, PcmParams, SND_PCM_FORMAT_FLOAT_LE) < 0) goto error_exit;
	if (snd_pcm_hw_params_set_channels(PcmHandle, PcmParams, Channels) < 0) goto error_exit;
	if (snd_pcm_hw_params_set_rate_near(PcmHandle, PcmParams, &SampleRate, 0) < 0) goto error_exit;
	if (snd_pcm_hw_params_set_buffer_size(PcmHandle, PcmParams, BufferFrames) < 0) goto error_exit;
	if (snd_pcm_hw_params(PcmHandle, PcmParams) < 0) goto error_exit;

	WindowData->QuitAudio = false;
	WindowData->SampleRate = SampleRate;
	WindowData->AudioRingBuffer.Initialize(BufferFrames, 2 * BufferFrames);
	InitBarrier.set_value(true);

	while(!WindowData->QuitAudio)
	{
		const auto ReadRange = WindowData->AudioRingBuffer.GetReadRange(BufferFrames);
		WindowData->AudioRingBuffer.InterleavedReadInto((float*)AudioBuffer.get(), ReadRange);
		// snd_pcm_writei is blocking
		if ((Result = snd_pcm_writei(PcmHandle, AudioBuffer.get(), ReadRange.TotalLength())) < 0)
		{
			// try to recover (e.g. underuns, otherwise bail)
			if (snd_pcm_recover(PcmHandle, Result,0) < 0) break;
		}
	}
	snd_pcm_drain(PcmHandle);
	snd_pcm_close(PcmHandle);
	return;

error_exit:
	InitBarrier.set_value(false);
}

int LinuxMain(void)
{
	auto WindowData = std::make_unique<FWindowData>();

	// Audio
	std::promise<bool> AudioInitPromise;
	std::future<bool> AudioInitBarrier = AudioInitPromise.get_future();
	std::thread AudioThread(AudioThreadFunc, WindowData.get(), std::move(AudioInitPromise));
	AudioInitBarrier.wait();
	bool HasAudio = AudioInitBarrier.get();
	if (!HasAudio) { AudioThread.join(); return 1; }

	std::vector<float> LChannelBuffer(WindowData->AudioRingBuffer.PerChannelBufferLength());
	std::vector<float> RChannelBuffer(WindowData->AudioRingBuffer.PerChannelBufferLength());
	FAudio Audio{ WindowData->SampleRate, 0, LChannelBuffer.data(), RChannelBuffer.data() };

	// Window & GFX
	const int PixelScale = 2;

	WindowData->BufferWidth = 1920 / PixelScale;
	WindowData->BufferHeight = 1080 / PixelScale;
	WindowData->Width = PixelScale * WindowData->BufferWidth;
	WindowData->Height = PixelScale * WindowData->BufferHeight;

	std::unique_ptr<FColor, void(*)(void*)> VideoBuffer{ (FColor*)calloc(1, sizeof(FColor) * WindowData->BufferWidth * WindowData->BufferHeight), [](void* p) { free(p); } };
	FVideo Video{ WindowData->BufferWidth, WindowData->BufferHeight, VideoBuffer.get() };
	WindowData->Buffer = Video.Buffer;

	const size_t DeltasCount = 60;
	double Deltas[DeltasCount] = { 0.0 };
	int DeltaIndex = 0;
	FTime Time{};
	FInput Input{};

	if (InitWindow(WindowData)) return 1;

	double FrameStartTime = 0.0;

	for(;;)
	{
		if (!Update(WindowData, Input))
		{
			goto DoQuit;
		}
		
		auto AudioRange = WindowData->AudioRingBuffer.GetWriteRange(int(Time.DeltaTime * WindowData->SampleRate));
		Audio.SamplesToWrite = AudioRange.TotalLength();

		if (!GameUpdate(Video, Audio, Input, Time))
		{
			goto DoQuit;
		}

		WindowData->AudioRingBuffer.Write(Audio, AudioRange);

		double FrameEndTime = QueryTime();

		Time.DeltaTime = FrameEndTime - FrameStartTime;
		if (Time.DeltaTime > 1.0 / 30.0)
		{
			Time.DeltaTime = 1.0 / 30.0; // Clamp, e.g. when debugging
		}

		Time.ElapsedTime += Time.DeltaTime;
		FrameStartTime = FrameEndTime;

		Deltas[DeltaIndex++] = Time.DeltaTime;
		if (DeltaIndex == DeltasCount)
		{
			DeltaIndex = 0;
			auto Average = std::accumulate(std::begin(Deltas), std::end(Deltas), 0.0) / (double)DeltasCount;

			fprintf(stderr, "Fps: %f, Delta: %f\n", 1.0 / Average, Average);
		}
	}
DoQuit:
	WindowData->QuitAudio = true;
	AudioThread.join();
	return 0;
}
};

int main(int argc, char** argv)
{
	return Engine_XCB::LinuxMain();
}

#endif
